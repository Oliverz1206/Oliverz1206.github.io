---
layout: post
title: Fundemental Computer System Notes
date: 2024-05-26 11:33:00 +0800
categories: [Notes, Computer Engineering]
permalink: /Notes/Computer-Engineering/Fundamental-Computer-System-Notes/
math: true
---

# A. Gate and Transistors

## 1. Transistors

NMOS and PMOS are two types of electrically controlled switches. NMOS在Gate为高电平时导通，通常用在一个逻辑电路中的PDN (Pull-Down Network)， PMOS在Gate低电平时导通，通常用在一个逻辑电路中的PUN (Pull-Up Network)。

![Transistors](/assets/img/ECE550_Notes/Transistors.png){: width="600"}


## 2. Logic circuit

PDN: Implement function(input') 对于任何一个逻辑组合，其PDN形式应该写作关于信号的补全形式。
PUN: Implement function'(input) 对于任何一个逻辑组合，其PUN形式应该写作输出的补全形式。

### a. logic expression → logic circuit

在搭建逻辑电路时，将“逻辑与”看成串联，将“逻辑或”看成并联。

例如一个逻辑电路：
$$f(x_1,x_2,x_3)=\overline{x_1}(\overline{x_2}+\overline{x_3})$$

对于PUN我们应该写作：
$$f(\overline{x_1},\overline{x_2},\overline{x_3}) = \overline{x_1}(\overline{x_2}+\overline{x_3})$$
    
根据PUN的写法我们可以得到信号x2与x3并联，并且与x1串联。如果化简到最后有x1, x2, x3的补全形式出现，则在画图的时候应该将输入到相应的PMOS的Gate的信号为x1, x2, x3；如果存在x1, x2, x3的原信号出现在PUN的表达式中，则在画图中输入到相应的PMOS的Gate的信号会是x1, x2, x3的补全形式。
    
对于PDN我们应该写作：
$$\overline{f}(x_1,x_2,x_3)=\overline{\overline{x_1}(\overline{x_2}+\overline{x_3})}=x_1+x_2x_3$$
    
根据PDN的写法我们可以得到信号x2与x3串联，并且与x1并联。如果化简到最后有x1, x2, x3出现，则在画图的时候应该将输入到相应的NMOS的Gate的信号为x1, x2, x3；如果存在x1, x2, x3的补全信号出现在PUN的表达式中，则在画图中输入到相应的NMOS的Gate的信号就是x1, x2, x3的补全形式。在画图的时候应该将输出的补全形式忽略。
    
最终电路图为：

![PDN](/assets/img/ECE550_Notes/image.png){: width="300"}
_PDN_
![PUN](/assets/img/ECE550_Notes/image1.png){: width="300"}
_PUN_

**对于逻辑结构的化简，我们直接使用德摩根定律进行化简：**  

$$\overline{A \cdot B}=\overline{A} + \overline{B} \qquad \overline{A+B} = \overline{A} \cdot \overline{B}$$

> 更简单的方法是，如果已经得到了PDN电路，则在PUN电路中，将所有的PMOS连接从PDN中NMOS的串联变成并联，并联变串联即可实现PUN。相同的，如果已经得到PUN电路，则可以根据PUN中PMOS的连接方式串并联互换即可得到PDN。
{: .prompt-tip }

### b. logic circuit → logic expression
相反的，如果我们希望从逻辑电路中读到实际的逻辑组合，只需要观察PDN或者PUN每一条分支就可以写出逻辑。例如一个逻辑电路为：   

从图上可以看到

# B. Combinational Circuit

对于逻辑的表达方式，我们通常有SoP (sum of product) 表达和PoS (product of sum) 的表达方式。设计组合逻辑电路总共分三步：

- Describe the behavior using a truth table 画出真值表
- 从真值表中获得Boolean Expression，使用SoP和PoS表示
- 将真值表中的逻辑转换成门逻辑电路

## 1. Truth Table
列出所有的输入输出，将所有的输入组合列在表格的每一行，最好是以二进制从小到大写(000-001-010-011...)。最后将需要的输出值列在输出列中。


## **2. Boolean Expression**

#### a. Sum of Product Expression  

SoP标准式是**每个乘积项(表示用于乘积的项元)包含全部的变量。**从真值表中得到SoP的标准形式写法为三个步骤：
    
- 只关注真值表里输出为"1"的项。
- 根据真值表中输入的值列出输出为"1"的项的乘积项，输入为1的乘积项中使用**原信号**，输入为0的乘积项中使用**补全信号形式**。
- 将所有乘积项用"或"连起来。
    
例如以下真值表（half-adder的sum）：
    
|A|B|Sum|Expression (for output '1')|
|-|-| - |            -              |
|0|0| 0 |            /              |
|0|1| 1 |     $$\overline{A} B$$    |
|1|0| 1 |     $$A \overline{B}$$    |
|1|1| 0 |            /              |

最后将两个表达式用或连接即可：$Sum=\overline{A} B+A \overline{B}$

#### b. Product of Sum Expression

PoS标准式是**每个求和项(表示用于加和的项元)包含全部的变量。**从真值表中得到SoP的标准形式写法也为类似的三个步骤：
    
- 只关注真值表里输出为"0"的项。
- 根据真值表中输入的值列出输出为"0"的项的求和项，输入为1的求和项中使用**补全信号形式**，输入为0的乘积项中使用**原信号**。
- 将所有乘积项用"与"连起来。
    
|A|B|Sum|Expression (for output '0')   |
|-|-| - |              -               |
|0|0| 0 |            $A+B$             |
|0|1| 1 |              /               |
|1|0| 1 |              /               |
|1|1| 0 |$\overline{A} + \overline{B} $|

最后将两个表达式用与连接即可：$$Sum=(A+B)\cdot(\overline{A} + \overline{B})$$

### **3. Transfer to Circuit**

在已经知道逻辑表达式之后，可以直接画出逻辑门电路。同样值得注意的是，**德摩根定律在门电路搭建的时候依然可以使用。**

![image.png](../assets/img/ECE550_Notes/image2.png){: width="400"}

### **4. K-Map** 

K-map 是一种化简电路逻辑的一种方法，通常输入信号不多于4个，可以从图形上直观地找出相邻最小项。两个相邻最小项可以合并为一个与项并消去一个变量。

- 圈必须要画的越大越好，使用的圈要越少越好
- 布尔值为1的必须要在蕴含项中
- 蕴含项可以穿过K-map

## **C. Digital Arithmetic**

### **1. Binary Code Representation**

#### a. Binary and Hex Conversion

将十进制转换成二进制可以使用除法的形式进行转换。每次将需要转换的10进制数除以2，直到商为0，得到的余数按从前往后排列即可得到二进制数。16进制数可以通过2进制数从小到大每4位进行转换。
    
例如十进制数374：

| Expression |Remainder|
| 374/2=187  |    0    |
| 187/2=93   |    1    |
| 93/2=46    |    1    |
| 46/2=23    |    0    |
| 23/2=11    |    1    |
| 11/2=5     |    1    |
| 5/2=2      |    1    |
| 2/2=1      |    0    |
| 1/2        |    1    |

所以最终的变换为 $$(374)_10=(101110110)_2$$

#### b. 2's Complement

有符号数通常进行补码运算。获得补码的方式很简单。首位将会代表符号位，正数表示没有变化，负数表示为相反数的取反（符号位也取反）加一。

#### c. Float

Float 浮点数为32位。float的表示方法非常简单，MSB为符号位，后8位为指数位（要减去127，原因是表示负指数），最后23位为定精度小数部分。

例如，我们有一个小数表示为0x421B5800。二进制数表示为 0 **\|** 10000100 **\|** 00110110101100000000000。可以看到符号位为0，因此小数为正数；后面八位的值为132，减去127为5，说明为2^5；最后23是定精度小数，实际数位1.00110110101100000000000。定精度小数和十进制一致，即每一位往后都是以2为底的负指数值.


## **D. Sequential Circuit**

A sequential circuit is a type of digital circuit or digital system that stores and processes information sequentially, meaning it takes into account the current input and the previous state to determine its next state and output. 时序电路是一种按顺序存储和处理信息的数字电路或数字系统，这意味着它考虑当前的输入和前一个状态，以确定其下一个状态和输出。通常我们使用D触发器作为时序电路记忆模块/延迟模块，用于记忆当前状态。

### **1. Register**

#### a. Latch

##### i. SR Latch
SR 锁存器是最基础的锁存系统，可以锁存一个比特的数据。引脚分别命名为Set和Reset：
    
- Set=1而Reset=0：使SR锁存器输出设置为1
- Set=0而Reset=1：使SR锁存器输出恢复为0
- Set=0且Reset=0：使SR锁存器锁存当前状态
- Set与Reset不能同时为0，虽然逻辑输出为0，但是这会使得SR锁存器无法正常锁存，**会使Q输出会稳定为一个未知的状态**。

##### ii. D Latch
为了弥补SR锁存器出现的问题，并且尝试配合时钟信号的功能，提出了D锁存器。D锁存器的输入引脚分别为Data和Enable:

- Enable=1：使D锁存器输出设置为输入Data（Q=D）
- Enable=0：使D锁存器无论Data输入为多少均保持当前状态（Q=Q）

D锁存器没有不稳定状态，但是相应的问题是**D锁存器是高电平触发，也就是说在Clock为1的时候没有被锁存，还会随输入变化随时变化**。因此如果一个组合电路接在D锁存器后面，如果运算过快，会导致在一个时钟周期运算超过一次，这是我们所不想要的。
​    
#### b. D-Flip Flop
为了弥补D锁存器的问题，提出了DFF的概念。**DFF的逻辑不再是高电平触发，而是延边触发。**也就是说只有在clock从0→1或者1→0的那一瞬间输入的数据才会被锁存。

![image.png](../assets/img/ECE550_Notes/filp-flop.png){: width="300"}
_Positive Edge Trigger D-Flip-flop_

其本质可以看成两个D-Latch。当上升沿的时候，后一个latch锁存，下降沿时前一个latch锁存，这样就可以把数据在上升的瞬间锁存住。

#### c. Register File
Register File 包含三个地址输入和一个数据输入；包含两个数据输出。Register File的目的是为了让通过地址读入**两个**32比特的值（原因是因为ALU的计算通常是两个数字进行计算）和写入**一个**32bit的值（存入ALU计算后的结果）。
Register file通过Decoder将地址转成One-hot编码实现找到目标寄存器。通过tri-state buffer控制输出读取的目标寄存器。


### **2. Finity State Machine (FSM)**
Finite State Machine (FSM) is a digital circuit representing a specific sequential logic system type. It is used to control and sequence the operation of digital systems, such as microprocessors, digital controllers, and other digital devices. 有限状态机时时序电路中的一种形式。它用于控制和排序数字系统的操作，如微处理器、数字控制器和其他数字设备。通常我们使用激活表格(Excitation Table) 和状态图(State Diargam)。对于无论实现什么类型的状态机，我们都需要获得两个组合逻辑电路：生成下一个状态的逻辑电路和输出逻辑电路。

通常我们有米利状态机(Mealy FSM)和摩尔状态机(Moore FSM)。这两个状态机在硬件上的**唯一区别**只有输出的组合逻辑电路。米利状态机的输出与当前状态和输入有关；摩尔状态机输出只与当前状态有关。通常情况下，米利状态机的状态会比摩尔的少，但是对于输入信号的要求更高。同时，**Mealy的输出会比Moore的早一个周期，Moore的输出永远会有一个时钟周期的延迟。**因此我们可以根据需求选择使用哪种状态机。

![Moore State Machine](../assets/img/ECE550_Notes/image3.png)
Moore State Machine

![Mealy State Machine](../assets/img/ECE550_Notes/image4.png)
Mealy State Machine

**可以看到register输出的才是当前状态，而需要输入的则是下一个状态**。

实现状态机的步骤（无论何种状态机）为：

- 根据需求画出状态图，**并且要写出每一个状态代表的含义是什么**
- 根据状态图中的状态个数设定需要多少个DFF来存储状态
- 根据输入、输出画出激活表格
- 根据激活表格得到两个组合逻辑电路的逻辑表达式并用K-Map, Q-M法进行化简
- 根据表达式部署逻辑门，实现状态机

### **a. Moore State Machine**
Moore状态机输出只与当前状态有关。**因此，在画状态图时，输出应该画在状态中，激活表格里输出那一列没有额外的分列。**在这里使用一个例子来说明：时序输入一串二进制数字（如：100101001），使用状态机检测序列中是否有'101'存在，存在时输出1，否则输出0。

先画出状态图：（注意一定要检查每个状态是否有所有输入组合的指出去的箭头，总共箭头个数应该是状态总数*输入组合总数(n bit→2^n)）

![image.png](../assets/img/ECE550_Notes/image5.png)
    
根据状态图可以看到总共有四个状态，因此用2-bit的DFF即可存储状态。因此我们可以列出激活表格：
    
|Current State|Next State||Output|
|-|-|-|-|
||w=0|w=1||
|00|00|01|0|
|01|10|01|0|
|10|00|11|0|
|11|10|01|1|

因此我们可以得到（这里需要一位一位看）：
$D_{0-next}=w; D_{1-next}=D_0\overline{w}+D_1\overline{D_0}w; \\ P=D_0D_1$

### **b. Mealy State Machine**

Mealy除了与当前状态有关，还与输入有关。**因此，在状态图中输出应该写在输入旁边，并且激活表格中输出也有分列。**使用同样的例子来说明，先画出状态图：
![image.png](../assets/img/ECE550_Notes/image6.png)
    
从状态个数看出，依然需要2个register来存储当前状态。因此我们可以列出激活表格为：
    
|Current State|Next State||Output||
|-|-|-|-|-|
||w=0|w=1|w=0|w=1|
|00|00|01|0|0|
|01|10|01|0|0|
|10|00|01|0|1|
|**11**|**00**|**01**|**0**|**0**|

在这里需要注意的是，其中11的状态我们并未使用（unused state），但是在硬件中依然存在，即便在正常工作的中的状态机不会出现这个状态。这个问题通常叫**冷启动问题**。这个问题是在于，当给状态机通电的时候，DFF是极其不稳定的，如果刚好在不用的状态，则会不能正常进入状态机的工作状态。因此我们必须要保证让状态机在未使用状态进去到使用的状态中（最好是初始状态）。因此我们可以写作：
$D_{0-next}=w; D_{1-next}=\overline{D_1} D_0 \overline{w}; \\ P=D_1 \overline{D_0}$

## **E. Instruction Set Architecture (ISA)**
Instruction set architecture is a set of instructions that the CPU could able to run. ISA是一种能让CPU运行的指令集。

### **1. Code Execution**

ISA is stored in 'Code' section of the process memory, with Static Data, Heap, and Stack. 程序被存储在计算机内存中Code的部分。对于von Neumann计算机结构，其执行程序的流程大致如下：

1. Instruction Fetch: Read Instruction bit from memory 获取指令
2. Decode: Figure out what those bit mean 解码或者指令含义
3. Operand Fetch: Read registers 获取运算对象
4. Execute: Do the actual operation 进行数据操作和运算
5. Result Store: Write result to register or memory 将结果存入寄存器或者内存
6. Next Instruction: Figure out mem address of next instruction 获得下一个指令

### **2. M**icroprocessor without **I**nterlocked **P**ipeline **S**tages (MIPS)

#### a. MIPS Register file
32*32 total pointers usage in the MIPS operation system
    
![Register_usage.png](../assets/img/ECE550_Notes/Register_usage.png)
    
1. 32 * 32-bit general purpose int registers 32个32位通用寄存器

    $0 is always 0 其中0号寄存器永远是0
    
2. Floating-point registers
    
    Lo, Hi: 2 32-bit register 这个寄存器可以用于乘法计算，小数计算暂存的时候使用
    
3. Special purpose register
    
    1. PC (Program Counter) PC是指向指令的指针/存储的是指令的内存
    
        - PC=PC+4 → memory is byte-addressable and MIPS is 32bit ISA PC指针每次会加4，这是因为在内存中，每一个字节（8比特）都是可以独立访问的，而MIPS是32位的指令集，因此下一个指令应该是跳过4个字节。
    
        - PC 由于每次都是加4，所以导致最后两个比特永远是0，因此在跳转或者比较指令中，会将lw和sw还有指令address*4
    
    2. Stack pointer (\$sp) SP是指向stack的最底部的位置
    
    3. Frame pointer (\$fp) FP是指向stack的当前frame最顶部位置。比如说类似于递归，我们call很多方程的时候，\$fp就应该指向当前函数所开的Stack顶，\$sp就应该指向当先函数的Stack底。
    
    4. Return address (\$ra) RA是当一个函数结束时PC应该返回到的位置

#### b. MIPS Instruction format

Three main instructions: R (register-register), I (register-immediate), J (jump and call):
    
![Operation_Instructions.png](../assets/img/ECE550_Notes/Operation_Instructions.png)
    
**Opcode:** 6-bit operation code
    
**Rs**: 5-bit Source register **address** in regfile
    
**Rt**: 5-bit Target register **address** in regfile
    
**Rd**: 5-bit Destination register **address** in regfile
    
**Shamt**: 5-bit shift amount
    
**Immediate**: 16-bit immediate operand (10, 25..etc)
    
**Function**: 6-bit  function filed for identify more specific operation
    
**Address**: 26-bit target address to call / jump
    
~~**Note:** 区别R,I,J三种指令非常简单，只要有三个register出现的一定是R，只要指令中含有J的一定是J指令，其他的直接含有数字的指令都是I指令。~~

#### c. MIPS Operation

**Athematiric Operation**
    
|Op  |Discription         |Example        |Mark                      |
|-   |-                   |-              |-                         |
|add |[addition]          |add $1, $2, $3 |将$2+$3的值存到$1中        |
|addi|[add imm]           |addi $1, $2, 10|将$2+10的值存到$1中        |
|sub |[sub imm]           |sub $1, $2, $3 |将$2-$3的值存到$1中(没subi)|
|sll |[shift left]        |sll $1, $2, 10 |将$2左移10位并将结果存到$1中|
|sra |[shift right (sign)]|sra $1, $2, 10 |将带符号$2右移10位并存入$1中|

**Load & save Operation** 
    
|Op|Discription|Example|Mark|
|-|-|-|-|
|lw|[Load Word]|lw $1, 100($2)|从$2+100的内存地址中取出数据放到$1中|
|sw|[Store Word]|sw $1, 100($2)|将$1的数据放到$2+100的内存地址中 |
|li|[load imm]|li $1, 100|**[persudo]**将$1载入100 - (addi)|

**Note:** lw和sw指令和指针操作一致。例如\'lw \$1, 0(\$2)\'形如 \$1=\*(\$2)，同样的，对于'sw \$1, 0(\$2)'，等同于\*(\$2)=\$1或者\$2=&\$1。li指令类似于赋值指令，例如\$1=100;
    
**Branch & compare Instructions**
    
|Op|Discription|Example|Mark|
|-|-|-|-|
|bne|[if not equal]|bne $1, $2, 10|如果$1≠$2则PC跳至[PC+4+10*4]|
|beq|[if equal]|beq $1, $2, 10|如果$1=$2则PC跳至[PC+4+10*4]|
|bltz|[if less than]|bltz $1, 10|如果$1<0则PC跳至[PC+4+10*4]|
|blez|[if less eq than]|blez $1, 10|如果$1≤0则PC跳至[PC+4+10*4]|
|bgtz|[if big than]|bgtz $1, 10|如果$1>0则PC跳至[PC+4+10*4]|
|bgez|[if big eq than]|bgez $1, 10|如果$1>0则PC跳至[PC+4+10*4]|
|slt|[s less than t]|slt $1, $2, $3|如果$2<$3则$1为1，否则为0|
|slti|[s less than t i]|slti $1, $2, 100|如果$2<100则$1为1，否则为0|

**Jump Operation**
    
|Op|Discription|Example|Mark|
|-|-|-|-|
|j|[Jump]|j address|PC跳转到内存为addr的指令|
|jal|[Jump & Link]|jal address|PC+4存到$31寄存器并跳转到内存为addr的指令|
|jr|[Return]|jr $31|PC跳转/回到内存为寄存器的指令|

**Note:** $31在MIPS中是return address register，因此会将PC+4存储在里面。**注意！JR指令看似是J指令，实际是一个叫JII的指令！**


### 3. Function Call
function call的时候ra, fp, 所有s寄存器必须存到stack里



## **F. Datapath**

According to the von Neumann model, we could design the CPU as:

PC指令每一次移动四个比特（对于32位系统）

根据PC获得从内存中获得指令，根据指令从regfile中获得运算数据，ALU进行运算。最后对于Data memory进行存/取，最后写入



## Pipeline

Pipeline的作用是最大化处理器的工作流程（**improves throughtout**），使其能在每个clock cycle处理不同的instructoion：



Pileline 总共有五个stage（Fetch, Decode, Execute, Memory, Writeback）分别简称为F, D, X, M, W, 为了使每个步骤都能单独处理不同的指令，我们需要再每一个步骤添加寄存器，存储当前的PC，Instruction，还有当前的数据。因此每一个步骤能被单独的进行：



但是，不是所有的指令都能按照顺序一步步的放在一起。例如指令add $3, $2, $1和 lw $1, 0($3) 就不可能放在一块，原因是第二个指令lw需要用到add中register 3 计算后的结果。如果按顺序处理就会导致处理器的结果出错。这种情况被称之为**Hazard**，而为了处理它，我们需要添加**Stall，**就是空白指令，即没有任何指令的等待。

### 1. Dependence

两个instruction会产生以下两种关联：

- **Data**: 两个指令需要用到同一个register file/data location，即下一个指令需要用到上一个指令的计算结果。例如：

    ```C++
    x = y + 3;
    z = x + 3;
    ```

    Data dependences包含四种：RAR(Read after read), RAW (Read after write), WAR (Write after read), WAW (Write after write).

- **Control**：含有Branch，Jump等指令必须要等到判断语句或者跳转语句获得新的PC之后才能知道之后需要做什么。例如：

    ```C++
    if (x > 3) { x = x + 3; }
    else {y = x - 3;}
    ```

### 2. Harzard

由于包含以上的关联性，因此会产生对应的harzards：

- **Structual**：这个是datapath固有的问题，这个需要更新ISA以解决可能产生的问题。

- **Data**：这个Harzard就是刚才提到的Data dependence所相应会产生的问题。下一个ins需要用到前一个所要计算的结果，因此不能直接跟在后面。解决Data Harzard可以从软件和硬件方向同时解决。

    1. Software interlocks: 在不改变pipeline的情况下，编译器根据代码为中间插入NOPS，称之为code scheduling。Software interlocks会有一定的兼容性问题。例如一个程序在5-stage的处理器能跑通，但是如果换到7-stage的处理器就不一定能正确运行，因为中间加的nops的数量不是正确的。

    2. Hardware interlocks: 用硬件的方式为处理器添加NOPS。假设regfile是先写后读的方式，那么如果要读的寄存器和之前的ins需要写入的寄存器一致，那么则需要空出两个周期，为他们添加NOPS。这个写为：

        F/D.IR.RS1 or F/D.IR.RS2 == D/X.IR.RD or X/M.IR.RD

        当出现这种情况时，**下一个指令必须要等到上一个指令Memory stage(M) 结束后才能开始Decode(D)。[添加两个NOPS]**

    1. Bypass: Bypass可以将X stage和M stage结束后的结果直接返还给X stage的input使用。这样就可以减少等待或者添加NOPS，直接让结果用于下一个指令。

        如果有W-X bypass，则可以在W的时候将值bypass到下一个的X，可以减少一个nop

        如果有M-X bypass，则可以在M的时候将值bypass到下一个的X，则可以再减少一个nop，实现不需要nop即可完成

- **Control**：这个Harzard就是刚才提到的Control dependence所相应会产生的问题。下一个ins不知道将会被跳到哪一个，因此不能直接跟在后面。

    1. Branch Recovery：先假设没有branch取下一个地址运行，如果有branch了之后就把F/D和D/X的指令一下子清空成NOPS。当出现这种harzard的时候，**在branch指令进行到Excute stage(X)结束后下一个指令才能Fetch(F)。[添加两个NOPS]**

    2. Fast Branch：将branch和j的相关指令提前到D的步骤中，提早进行判断，这样的话只需要添加一个NOS即可完成

### 3. Pipeline Diagram

Pipeline Diagram是可以描述每一个指令在同一个时间点再执行哪一个stage。在同一个时间点不可能出现两个相同的stage



### 4. Bypassing

W-M bypass address是没有意义的，但是data input是有用的

W-M bypass 在前一个是lw，后一个是sw的指令在用到lw出来的目标寄存器时有用

e.g. lw $3, 0($2); sw $3, 20($6)

但是如果lw后面需要对应的

X-M bypass 

e.g. addi \$3, \$4, 100; 

如果不branch，则



## Memory Hierarchy

### 1. 计算机储存结构

一个计算机想要从内存中访问数据需要MMU（memory memagement unit）来控制。每一个程序在计算机中不是单纯的共用主内存，而是通过MMU的帮助让每个程序”以为“他们都有4GB的内存。这些额外的内存实际是存储在硬盘中。这个内存地址不是物理上的内存里的数据，而是一个虚拟地址（virtual address），这时候MMU会使用页表（page table）将虚拟的地址映射到实际的物理地址。如果数据在主内存（main memory）中，则直接返回映射到的物理地址。处理器根据根据这个物理内存来访问cache，并且根据cache是否hit或者miss更新cache的数据。如果数据不再主内存中，则称之为页面错误（page fault），处理器将会从硬盘中把当前page的内容加载到主内存中，然后再用物理地址继续去尝试是否成功hit cache。

### 2. 存储结构（memory hierarchy）

在一个计算机系统里，处理器不会直接访问主内存（main memory），因为实主内存的速度非常的慢。然而，处理器往往会访问更小块的内存，称之为缓存（cache）。缓存比内存小很多，但是速度非常的快。但是由于缓存比较小，不一定存储了处理器想要的处理的数据。这样缓存就需要向上一级更大的缓存或者内存的数据，并把他加载进来。

![image7.png](../assets/img/ECE550_Notes/image7.png)

因此一个缓存有以下几个参数和操作：

- **Access**： 对内存进行读写操作称之为access

- **Hit**：在当前内存中找到了数据

- **Miss**：在当前内存没有找到数据

- **Fill**：将数据放入至内存中

- **%miss**：Miss/accesses，即没有找到数据的次数比上总访问（读写）的次数。

- **thit**：成功找到数据所需要花费的时间

- **tmiss**：没有找到数据所花费的时间

tavg = thit + %miss  *tmiss 平均访问内存的花销公式。***注意：这个里面thit的花销一定存在，即函数不是tavg = thit  (1-%miss) + tmiss  %miss，因为无论什么数据都需要先查存不存在，无论是最后是不是想要的数据。**从这个公式里可以得到：Large内存会有较低的%miss但是thit比较高，相反Small内存会有较低的thit但是%miss较高，因此我们需要使用memory hierarchy来调和这两个内存，让其以从小到大逐级进行缓存。

在计算机内存中有有几个比较常见的经验规则：

- **10/90 rule**：一个程序大概有90%的时间访问大概10%左右的内存空间

- **Temporal locality（时间上）**：一般最近被访问的数据或者指令**更加有可能之后被访问或者利用到**。

- **Spatial locality（空间上）**：一般最近被访问的数据或者指令的**附近/相邻的空间**之后更可能被访问或者利用到。

由于每一层的缓存都会更大一些, 因此在较小的缓存中使用SRAM结构，原因是SRAM速度非常快, 而后面的较大的缓存或者主要的内存就要使用DRAM结构，原因是SRAM的占用面积太大，并且非常昂贵，而DRAM的大小比较小, 密度较高且相对便宜。

## 3. 缓存（Cache）

**Block**： Cache的最基础组成单元是blocks，即每个单独的Cache是若干个blocks组成。在32bit系统里，每一个block至少是4B。（**使用Block的原因是spatial locality**）

**Set**：一个set可以由多个blocks组成。例如四个block可以组成一个Set，其中每一个block排列称作**way**，例如一个set由两个block，则就用way0, way1分别表示在一个set中的第一个block和第二个block。

**注意**：如果一个set里只有一个way，则说明index直接指向的是block，这个称之为**direct-mapped（DM）**，如果整个cache只有一个set则说明index就不存在了，这个被称之为**fully-associative（FA）**。其他情况，例如一个set里有两个way，则称之为**2-way set-associative（SA）**。

处理器将会使用一个32位的地址来寻址Cache。整个地址分为三个部分：Tag，Index和Offset。

- Tag描述的是当前cache是加载的main memory的哪一个片段

    其中tag array中还包含一个1bit的valid bit和一个dirty bit，用于描述当前blcok是否可用和当前block的数值是否被更改过。（**tag array 相当于是给cache block额外添加的一些小标记，其大小可以用tag overhead衡量**）

    tag的bit大小是索引的address大小减去index和offset的大小剩下的bit全部都是tag

    tag = address / (sets * block_size)

- Index描述额是当前的cache中的哪一个block

    index占用的bit个数是block的个数的log2，即8block→3bit, 4block→2bit

    index = (address / block_size) % sets

    index是中间段的原因是在于：spetial locality的问题。假设index放在最高位，那么一个连续的片段放在相同一个block中，如果现在将一个数组存在内存中，则再一个block中就会有连续的数据（...）。

- Offset描述的是当前block里的哪一个byte（因为memory实际上是byte addressable，意味着每一个byte都可以被索引，所以用offset表示哪一个byte）

    offest的bit个数是一个block的bytes大小的log2，即4B→2bit, 8B→3bit

    offset = address % block_size

**如果认为是HIT，在direct-mapped则必须要当Set=index的时候tag=target_tag且valid bit=1，否则就是MISS。在 X-ways associative中，只要Set=index的时候，只要其中一个way中的tag=target_tag并且valid bit=1，即认为他是HIT的。**

在X-ways associative中存在着替换的顺序问题，即如果程序发现miss了，程序将要将哪一个ways中的数据更新。这个问题有很多种解决方法：

- FIFO：用一个队列存储block的写入顺序，hit后不改动way的顺序，还是按照顺序覆盖队头的那个way

- LRU：用一个队列存储block的写入顺序，如果hit了就把这个way移到队尾。如果Miss了但是ways里还有invalid，优先覆盖invalid。如果ways里已经没有invalid block了，则覆盖队列头部的那个way

- NMRU：

- Random：

- Belady's：

#### 4. Write Propagation

如果需要更新block的数据，有两种方法进行给更新：

- Write-htru：立即更新数据，慢

- Write-back: 使用dirty bit用于提示是否被更改过，如果是1则说明更改过，在加载新的数据之前就把带有dirty bit的数据向下更新，然后加载新的数据进来的时候就把所有的dirty bit再次清零。

#### 5. Performance

减少%miss的最简单方法是增大cache的容量（capacity）。这虽然会导致thit略微增大，但是总体的tavg是在减小的。

如果容量固定，增大块的大小（block size）也可以更好的处理spatial locality，减少tag overhead，但是相应的thit会略微增加，同时冲突问题（conflicts）也会更加频繁

tag overhread = tag size / data size (in each block)

conflicts：不同的在主内存中的数据块映射到相同的cache中，致使这个cache block会频繁的更新，从而降低运行效率。



**Tag，index，offset的大小变化：**

增大block，cache和associativity大小不变→tag不变，index减少，offset增大

增大sets，cache和associativity大小不变→tag不变，index变大，offset减少

增大associativity，cache和block的大小不变→tag变多，index变小，offset不变

增大cache，block和associativity大小不变→tag变少，index变多，offset不变

## Virtual Memory

使用虚拟内存的目的是给予系统的一种错觉让每个32位的程序都以为有4GB的空间可以操作。virtual memory的好处在于，它可以让每一个系统兼容运行这个程序，不需要让程序自己去管理使用多少内存。他将部分的数据存储不在内存中的可以放在硬盘里。

Page是硬盘中的存储单元，通常非常小（~4KB），并且受到MMU的管理。**使用page的原因是减少PT的大小。**

程序使用一个virtual address（VA）的地址对一个Page的数据进行索引，**virtual memory的长度就是处理器总线宽度**，32bit系统拥有32bit virtual memory。因为本质上memory和disk都是Byte addressable，因此在virtual memory中包含两个部分，高位的部分是virtual page number（VPN），低位的部分是page offests（POFS），相当于告诉”一本书的第几页第几行“。

内存则使用physical address（PA）的地址对主内存内的Page数据进行索引，physical address 通常比virtual memory小（64bit系统），且**他的长度就是内存的大小，4GB main memory拥有32bit的physical address。**其中高位的部分为Physical page number，低位还是POFS。

![image8.png](../assets/img/ECE550_Notes/image8.png)

POFS的大小实际上是由page的大小决定，例如一个page的大小是64KB，则POFS应该是log2(64K)=16。那么VPN的长度就是总线长度减去POFS的长度。相同的，PPN的长度就是物理最大地址长度减去POFS。

将虚拟地址转换为物理地址的过程为**查表（table lookup）**。这个过程通过**页表（page table）**实现，即页表里记录着这个VPN实际上是在物理主内存的哪个地方，还是存在硬盘中。

页表也占用空间，table里的每一个占用的大小为**Page table entries（PTEs）**。但是如果一个页表太大，则会导致查表的速度大大减慢，因此可以使用**多级页表（muti-level page table）**，即可以将page table的拆分成比较小的部分。例如讲VPN再拆成两个部分，前一个部分用于索引第一级的page table，后半部分查找第二级的page table。这个就跟virtual memory的组成一样，相当于在说”第几个页表的第几个page“。

#### **Example：**

    一个系统的总线是X-bit，一个page的大小为N Byte，主内存的大小为M Byte，每一个PTE的大小为P bytes。
    
    VA的大小为log2(X) bit
    
    VM的大小为2^X B
    
    POFS的大小为log2(N) bit
    
    PPN的大小为log2(M)-POFS bit
    
    **一级page table：**
    
        VPN的大小为VA-POFS bit
    
        PT中需要存的所有PTE的个数为2^VPN 或者 VM/N （虚拟内存的大小除以Page大小）
    
        PT占用的大小为2^VPN*P B
    
    **二级page table：**
    
        假设第一级page table里存的指针的大小为Q
    
        VPNL的大小为log2(N/P) bit
    
        VPNH的大小为VA-VPNL-POFS bit
    
        VPNL的PT占用大小为N B
    
        VPNH的PT占用大小为(VA-VPNL-POFS)*Q B

## Operation System

### 1. Interrupt, exception and system call

#### a. External event and interrupt

在程序运行时，通常会有**外部的事件**需要即刻被处理，例如网络数据已经完全加载，需要向硬盘读取或者写入数据，修改电脑内部时间等等。

处理器在此时可以通过两种方法进行处理：

Polling：定期持续询问是否完成 (持续询问，非常低效)

Interrupts：继续做其他任务直到外部设备提供硬件信号

- 根据外部提供的中断请求并根据中断的优先级（Interrupt controller prioritize）通知处理器

- 处理器中断当前任务的处理进程并跳转到中断处理进程（interrupt handler）中，并让OS进入privileged mode。

- 处理器运行中断请求的程序

- 处理器从中断中返回之前的程序，并退出privileged mode

在操作系统启动的时候会建立一个**interrupt vector**以设置所有的指针指向不同的中断操作的例行程序。

其中一个最常用的中断方式是计时器中断。这种方式可以使中断以定时的方式产生，从而可以让处理器同时运行多个程序（mutitasking）。【只是看起来使并行的处理多个程序，但是实际上是不断地让系统在多个程序中切换】

#### b. Exception

与interrupt相反，expection是在**系统内部**指令运行的过程中一些不正常的情况从而导致处理器暂时终止运行，它通常发生在其中一个指令中，例如：虚拟地址没有被正确翻译为物理地址，除法运算除以0，使用未定义的指令集。

与中断相比，Expections通常会知道哪一个指令引起的错误，并且系统可能会根据不同的错误进行重试（restart）或者终止进程（kill）。

Exception的处理方式跟中断一致，也会有一个exception handler让OS进行处理。指令集中某些指令会给出中断的数字信息。

#### c. 系统调用（System call）

当程序需要系统进行一定的操作的时候会使用system call，例如从硬盘中获得数据，链接网络，获得准确的时间，复制新进程等。

通过使用syscall，程序可以通过设置某些寄存器让系统知道程序的要求。但是系统有权可以拒绝程序的需求并且返回错误。这种系统调用实际上比较慢，因此，为了避免多次使用系统调用，使用用户空间（Userspace libraries）会更加迅速，例如malloc函数会分配内存，但是实际上他不会每次做system call，而是系统调用一次很大的内存块给程序，然后程序自己分配和管理那个内存块。

### 2. 文件系统（Filesystem）

在硬盘和系统中，每一个可以被索引到的存储单元可以称作为Blocks。Blocks可以被整合为block groups。一个系统中的Filesystem就是由若干个blocks组成的。

在UNIX系统下，**Inode**是用于描述其Filesystems的数据结构。它包含了所有的关于这个文件的信息，包括所有者，权限，访问时间，被存储在哪个地方，占用了多少空间，**唯独不保存文件名**。Inodes的大小是固定的**256 bytes**。

在inode中，文件保存的数据用**指针**描述。它保存的是每个block的地址。由于每一个block的大小比较小（例如4KB），使用所有的指针指向直接的数据blcok的大小也比较小（**Functionality problem**），因此我们需要**Add a level of indirection，**即inode指针指向的block中也全部是指针，分别再指向数据，这样子指向的数据就比较多了，但是坏处是添加indirection会使访问数据的速度变慢，对于小文件非常不值得，因此再实际的indoes中包含：

- 12 direct pointer（直接指向数据block，可以包含48KB数据）

- 1 indirect pointer（一层indirection，可以额外包含4MB数据）

- 1 doubly indirect pointer（二层indirection，可以额外包含4GB数据）

- 1 triply indirect pointer（三层indirection，可以而外包含4TB数据）

通过包含不同层级的指针和indirection，小文件可以通过direct pointers，比较大的文件可以分别通过使用一级至三级的indirection指针进行保存，从而达到大文件小文件都可以用inode保存，并且能保证小文件存取速度快。大文件也可以通过使用cache保存indirect blocks中的pointers让访问的速度变快。这是一种**make the common case fast 的一种表现。**

Example：



在UNIX系统中，**路径（directories）也是一个文件，用inode存储。**这样每个directories的inode的里存储的是{name, inode #}的键值对，他们也是指针，相当于指向的是路径下的文件的inode！因此，如果要找到某一个路径底下的文件，会在这个键值对中寻找（遍历）匹配的name，然后获得其inode的指针，找到的对应的文件。

除了路径，UNIX系统的文件类型还包括：（也都是用inodes）

- Regular file：常规的所有文件

- Directories：路径

- FIFO（First-in first-out）：通过队列的方式使得两个process进行通讯

- Symlinks

- Device：硬件设备

- Sockets

### 3. 进程（Processes）

一个进程是一个正在运行的程序的实例（**Instance of a program**）。每一个process都有一个Process ID（**PID**），并且都是不同的，用于区分每一个process。在一个OS系统里都会存在一个scheduler用于计划指令的顺序。最基础的就是一个简单的循环队列，更高级的包含优先计划和更高级的算法，而OS自身会知道什么process正在运行。

#### a. 上下文切换（Context Switch）

当遇到中断（Interrupt）时，scheduler会找到接下来需要运行什么。这时候OS会执行上下文切换（**context switch**）

- 当前的所有寄存器内的值都会OS的预处理数据结构中

- 将当前处理器的根页表指向新的process的页表（页表：虚拟内存实现中用于存储物理地址和虚拟地址之间映射关系的数据结构）

- 将新进程的数据加载进寄存器中并运行新进程

- 当中断任务完成后，系统将会从中断进程中返回，获得原先保存的数据和PC，继续执行之前的任务

#### b. 创建进程（Process Creation）

生成一个新的Process可以通过很多种方法，其中最常见的一种是通过**复制当前的进程**。使用复制来生成新的进程有诸多好处：他能复制当前的环境变量，原始设置等，减少重复操作；其次是在memory中不需要额外花时间加载新的东西，所有的数据、代码片段等都已经存在（注意：**只会拷贝页表**，也就是说只拷贝指针（浅拷贝），这样可以不用复制所有的数据，两者指向同一个地方）。因此使用这种方法开始新的进程的效率会比较高。

在UNIX系统中，可以使用**fork()**函数来复制当前进程。如果此函数返回0，说明这是子进程（复制出来的进程），如果>0，则返回的值是子进程的PID，并且说明是父进程。但是复制之后**不能保证哪一个先被运行**，即使是父进程也不一定会先运行，多核处理器可以同时运行子和父进程。

当复制完新进程后，可以使用**exec()**函数将新的程序加载进入内存，并且将会覆盖当前存在内存中的数据和重置栈和堆的指针，成功执行exec后，执行exec调用的原始程序将不再存在于进程中，而新加载的程序将接管执行。**因此，除非在执行exec操作期间发生错误，否则原始程序不会在调用exec之后恢复执行（never return）。**

kill() 函数可以把当前的进程杀死。但是其不是立刻回到父进程的操作，实际上是向当前进程发送一个信号。当前进程可以根据这个信号做出反应，也可以完全忽略此信号。

#### c. 线程（threads）

一个进程中包含很多线程（threads）。线程可以同时进行（**excute concurrently**），有着独立的寄存器和独立的栈空间（**different register and stack**），但是他们共享同一个虚拟地址（**share virtual address space**）。由于线程可以同步进行，程序需要有同步性（synchronization）来保证不同进程之间能正确的共享数据，没有竞争和冲突的关系。

#### d. 启动（Booting）

我们需要**Bootloader**来获取我们电脑的第一个进程。在电脑启动时，vierual memory不可用，BIOS通过启动代码（startup code）启动并开始读取硬盘0号分区的内容（通常非常小的分区）来启动（First stage bootloader）。然后他会根据这个内容读取第二阶段的分区内容（second stage bootloader），包含一些简单的菜单和选项，并且读取文件系统并将OS核心加载到内存中并启动。当OS核心启动后，页表，中断处理，空闲进程等就会建立。

**Init 是计算机中第一个正常的程序，OS将加载/bin/init，并将此进程的PID设为1。**Init将会阅读在/etc中所有的配置信息，通过/bin/login, ssdh等路径生成（spawn）其他的进程和程序，并且定期清理一些孤立或者终止的进程。

### 4. 接口（input output I/O）

一个电脑系统包含了很多IO接口，因为这是与外界进行交互的窗口。处理器接收和处理这些IO设备的信号通常有两种方法：

- 设置In/Out 指令集（**In/Out instruction**）：可以使处理器从固定的IO接口读和写入

- 内存映射（**Memory mapped**）：将一部分的物理地址直接映射到IO设备中，IO设备的数据的读或者写的数据都被地址映射了，处理器可以直接通过访问内存的方式访问这些接口。

#### a. Load data from disk to memory

之前已经提到过OS会使用中断来加载硬盘中的数据。那么将硬盘中的数据加载到内存中有两种方式：

- 使用OS中的指令，将内存映射为硬盘的接口的数据写入到主内存中。每次写入几KB至几MB不等，直至写入完成。

- 使用DMA（**Direct Memory Access**）：设置DMA，让DMA去做加载硬盘数据到内存数据的操作，完成后反馈给CPU（间接方式实现加载）

#### b. Reliability

增大一个系统的稳定性有不同的操作：

- 解决文件存储大小的问题（**Functionality problem**）：添加indirection（Filesystem）

- 解决处理性能的问题（**Performance problem**）：添加cache（Memory Hierachy）

- 解决数据可靠性的问题（**Reliability problem**）：添加redundancy（冗余数据→使用RAID系统）

RAID系统（Redundant Array of Inexpensive Disks）是一种简单且暴力的方法，即将相同的数据保存很多份以增加数据的可靠性；如果复制一份，则叫RAID1。如果其中一个盘的数据损坏或者不正确，只需要将另外一个的数据拿来覆盖即可。



Interrupt are not linked to instructions running on the CPU

Pipeline improves throughout

performance problem→cache



[MIPS Opcode](../assets/img/ECE550_Notes/MIPS_Opcode_Reference.xlsx)

