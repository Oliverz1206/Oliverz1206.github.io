---
title: Fundamental Computer System Notes
date: 2024-05-26 11:33:00 +0800
categories: [Notes, Computer Engineering]
tags: [notes]
math: true
---

## A. Gate and Transistors

### 1. Transistors

NMOS and PMOS are two types of electrically controlled switches. NMOS 在 Gate 为高电平时导通，通常用在一个逻辑电路中的 PDN (Pull-Down Network)， PMOS 在 Gate 低电平时导通，通常用在一个逻辑电路中的 PUN (Pull-Up Network)。

![Transistors](/assets/img/notes/ece550/Transistors.png){: width="600"}


### 2. Logic circuit

PDN: Implement function(input') 对于任何一个逻辑组合，其 PDN 形式应该写作关于信号的补全形式。
PUN: Implement function'(input) 对于任何一个逻辑组合，其 PUN 形式应该写作输出的补全形式。

#### a. logic expression → logic circuit

在搭建逻辑电路时，将“逻辑与”看成串联，将“逻辑或”看成并联。

例如一个逻辑电路：
$$
f(x_1,x_2,x_3)=\overline{x_1}(\overline{x_2}+\overline{x_3})
$$

对于 PUN 我们应该写作：
$$
f(\overline{x_1},\overline{x_2},\overline{x_3}) = \overline{x_1}(\overline{x_2}+\overline{x_3})
$$
    
根据 PUN 的写法我们可以得到信号 x2 与 x3 并联，并且与 x1 串联。如果化简到最后有 x1, x2, x3 的补全形式出现，则在画图的时候应该将输入到相应的 PMOS 的 Gate 的信号为 x1, x2, x3；如果存在 x1, x2, x3 的原信号出现在 PUN 的表达式中，则在画图中输入到相应的 PMOS 的 Gate 的信号会是 x1, x2, x3 的补全形式。
    
对于 PDN 我们应该写作：
$$
\overline{f}(x_1,x_2,x_3)=\overline{\overline{x_1}(\overline{x_2}+\overline{x_3})}=x_1+x_2x_3
$$
    
根据 PDN 的写法我们可以得到信号 x2 与 x3 串联，并且与 x1 并联。如果化简到最后有 x1, x2, x3 出现，则在画图的时候应该将输入到相应的 NMOS 的 Gate 的信号为 x1, x2, x3；如果存在 x1, x2, x3 的补全信号出现在 PUN 的表达式中，则在画图中输入到相应的 NMOS 的 Gate 的信号就是 x1, x2, x3 的补全形式。在画图的时候应该将输出的补全形式忽略。
    
最终电路图为：

![PDN](/assets/img/notes/ece550/Logic.png){: width="500"}
_PDN (left) and PUN (Right)_

**对于逻辑结构的化简，我们直接使用德摩根定律进行化简：**  

$$
\overline{A \cdot B}=\overline{A} + \overline{B} \qquad \overline{A+B} = \overline{A} \cdot \overline{B}
$$

> 更简单的方法是，如果已经得到了 PDN 电路，则在 PUN 电路中，将所有的 PMOS 连接从 PDN 中 NMOS 的串联变成并联，并联变串联即可实现 PUN。相同的，如果已经得到 PUN 电路，则可以根据 PUN 中 PMOS 的连接方式串并联互换即可得到 PDN。
{: .prompt-tip }

#### b. logic circuit → logic expression
相反的，如果我们希望从逻辑电路中读到实际的逻辑组合，只需要观察 PDN 或者 PUN 每一条分支就可以写出逻辑。例如一个逻辑电路为：   

从图上可以看到

---

## B. Combinational Circuit

对于逻辑的表达方式，我们通常有 SoP (sum of product) 表达和 PoS (product of sum) 的表达方式。设计组合逻辑电路总共分三步：

- Describe the behavior using a truth table 画出真值表
- 从真值表中获得 Boolean Expression，使用 SoP 和 PoS 表示
- 将真值表中的逻辑转换成门逻辑电路

### 1. Truth Table
列出所有的输入输出，将所有的输入组合列在表格的每一行，最好是以二进制从小到大写(000-001-010-011...)。最后将需要的输出值列在输出列中。例如 A, B 和 Cin 为输入， Sum 和 Carryout 为输出的 Full Adder：

| A | B | Cin | Sum | Carry Out |
|---|---|-----|-----|-----------|
| 0 | 0 |  0  |  0  |     0     |
| 0 | 0 |  1  |  1  |     0     |
| 0 | 1 |  0  |  1  |     0     |
| 0 | 1 |  1  |  0  |     1     |
| 1 | 0 |  0  |  1  |     0     |
| 1 | 0 |  1  |  0  |     1     |
| 1 | 1 |  0  |  0  |     1     |
| 1 | 1 |  1  |  1  |     1     |


### 2. Boolean Expression

#### a. Sum of Product Expression  

SoP 标准式是**每个乘积项(表示用于乘积的项元)包含全部的变量。**从真值表中得到 SoP 的标准形式写法为三个步骤：
    
- 只关注真值表里输出为**"1"**的项。
- 根据真值表中输入的值列出输出为"1"的项的乘积项，输入为 1 的乘积项中使用**原信号**，输入为 0 的乘积项中使用**补全信号形式**。
- 将所有乘积项用"或"连起来。
    
例如以下真值表（half-adder 的 sum）：
    
| A | B | Sum | Expression (for output '1') |
|---|---|-----|-----------------------------|
| 0 | 0 |  0  |             /               |
| 0 | 1 |  1  |      $$\overline{A} B$$     |
| 1 | 0 |  1  |      $$A \overline{B}$$     |
| 1 | 1 |  0  |             /               |

最后将两个表达式用或连接即可：$$ Sum=\overline{A} B+A \overline{B} $$

#### b. Product of Sum Expression

PoS标准式是**每个求和项(表示用于加和的项元)包含全部的变量。**从真值表中得到SoP的标准形式写法也为类似的三个步骤：
    
- 只关注真值表里输出为**"0"**的项。
- 根据真值表中输入的值列出输出为"0"的项的求和项，输入为1的求和项中使用**补全信号形式**，输入为0的乘积项中使用**原信号**。
- 将所有乘积项用"与"连起来。
    
| A | B | Sum |   Expression (for output '0')   |
|---|---|-----|---------------------------------|
| 0 | 0 |  0  |             $$A+B$$             |
| 0 | 1 |  1  |                /                |
| 1 | 0 |  1  |                /                |
| 1 | 1 |  0  |$$ \overline{A} + \overline{B} $$|

最后将两个表达式用与连接即可：$$ Sum=(A+B)\cdot(\overline{A} + \overline{B}) $$


### 3. Transfer to Circuit

在已经知道逻辑表达式之后，可以直接画出逻辑门电路。同样值得注意的是，**德摩根定律在门电路搭建的时候依然可以使用。**

![image.png](/assets/img/notes/ece550/DeMorgan.png){: width="500"}

### 4. K-Map

K-map 是一种化简电路逻辑的一种方法，通常输入信号不多于 4 个，可以从图形上直观地找出相邻最小项。两个相邻最小项可以合并为一个与项并消去一个变量。

- 圈必须要画的越大越好，使用的圈要越少越好
- 布尔值为 1 的必须要在蕴含项中
- 蕴含项可以穿过 K-map

例如 [Full Addder](#1-truth-table) 的 Carry Out 进行逻辑简化，如果根据 Sum of Product 直接书写则为：

$$
\text{Cout} = \overline{A} \, B \, \text{Cin} + A \, \overline{B} \, \text{Cin} + A \, B \, \overline{\text{Cin}} + A \, B \, \text{Cin}
$$

接下来我们列出 K-map：

> 如果是三个输入则两个输入一组，另外一个一组，如果四个就是两个输入分两组。如果两个一起写一定要按照 00, 01, 11, 10 的写法，相邻之间只变化一个字节。
{: .prompt-warning }

| A \ BC | 00 | 01 | 11 | 10 |
|--------|----|----|----|----|
|   0    | 0  | 0  | 1  | 0  |
|   1    | 0  | 1  | 1  | 1  |

从大圈开始（8 个元素->4 个元素->2 个元素）一个个找，可以看到 AB, AC, BC 均可以画一个 2 元素的小圈：

![image.png](/assets/img/notes/ece550/Kmap.png){: width="500"}

于是我们可以得到：

$$
\text{Cout} = A B + A \, \text{Cin} + B \, \text{Cin}
$$

即为简化结果。

> 其最本质的原理是当相邻元素时，例如可以看到竖着的圈，**无论 A 是什么**，BCin 都是 1 的时候都是 1，因此就可以将其简化为$$ BC $$。这种情况称为 A Don't Care。同样的，像横着的圈可以看到无论 B 是什么，当 A 为 1，C 为 1 时都是 1，因此也能做简化。
{: .prompt-info }

---

## C. Digital Arithmetic

### 1. Binary Code Representation

#### a. Binary and Hex Conversion

将十进制转换成二进制可以使用除法的形式进行转换。每次将需要转换的 10 进制数除以 2，直到商为 0，得到的余数按从前往后排列即可得到二进制数。16 进制数可以通过 2 进制数从小到大每 4 位进行转换。
    
例如十进制数 374：

| Expression | Remainder |
|------------|-----------|
| 374/2=187  |     0     |
| 187/2=93   |     1     |
| 93/2=46    |     1     |
| 46/2=23    |     0     |
| 23/2=11    |     1     |
| 11/2=5     |     1     |
| 5/2=2      |     1     |
| 2/2=1      |     0     |
| 1/2        |     1     |

所以最终的变换为 $$ (374)_{10}=(101110110)_2 $$

#### b. 2's Complement

有符号数通常进行补码运算。获得补码的方式很简单。首位将会代表符号位，正数表示没有变化，负数表示为相反数的取反（符号位也取反）加一。

#### c. Float

Float 浮点数为 32 位。float 的表示方法非常简单，MSB 为符号位，后 8 位为指数位（要减去 127，原因是表示负指数），最后 23 位为定精度小数部分。

例如，我们有一个小数表示为 0x421B5800。二进制数表示为 0 **\|** 10000100 **\|** 00110110101100000000000。可以看到符号位为 0，因此小数为正数；后面八位的值为 132，减去 127 为 5，说明为 2^5；最后 23 是定精度小数，实际数位 1.00110110101100000000000。定精度小数和十进制一致，即每一位往后都是以 2 为底的负指数值.

---

## D. Sequential Circuit

A sequential circuit is a type of digital circuit or digital system that stores and processes information sequentially, meaning it takes into account the current input and the previous state to determine its next state and output. 

时序电路是一种按顺序存储和处理信息的数字电路或数字系统，这意味着它考虑当前的输入和前一个状态，以确定其下一个状态和输出。通常我们使用 D 触发器作为时序电路记忆模块/延迟模块，用于记忆当前状态。

### 1. Register

#### a. Latch

##### i. SR Latch
SR 锁存器是最基础的锁存系统，可以锁存一个比特的数据。引脚分别命名为 Set 和 Reset：
    
- Set=1 而 Reset=0：使 SR 锁存器输出设置为 1
- Set=0 而 Reset=1：使 SR 锁存器输出恢复为 0
- Set=0 且 Reset=0：使 SR 锁存器锁存当前状态
- Set 与 Reset 不能同时为 0，虽然逻辑输出为 0，但是这会使得 SR 锁存器无法正常锁存，**会使 Q 输出会稳定为一个未知的状态**。

##### ii. D Latch
为了弥补 SR 锁存器出现的问题，并且尝试配合时钟信号的功能，提出了 D 锁存器。D 锁存器的输入引脚分别为 Data 和 Enable:

- Enable=1：使 D 锁存器输出设置为输入 Data（Q=D）
- Enable=0：使 D 锁存器无论 Data 输入为多少均保持当前状态（Q=Q）

D 锁存器没有不稳定状态，但是相应的问题是**D 锁存器是高电平触发，也就是说在 Clock 为 1 的时候没有被锁存，还会随输入变化随时变化**。因此如果一个组合电路接在 D 锁存器后面，如果运算过快，会导致在一个时钟周期运算超过一次，这是我们所不想要的。
​    
#### b. D-Flip Flop
为了弥补 D 锁存器的问题，提出了 DFF 的概念。**DFF 的逻辑不再是高电平触发，而是延边触发。**也就是说只有在 clock 从 0→1 或者 1→0 的那一瞬间输入的数据才会被锁存。

![image.png](/assets/img/notes/ece550/Flipflop.png){: width="450"}
_Positive Edge Trigger D-Flip-flop_

其本质可以看成两个 D-Latch。当上升沿的时候，后一个 latch 锁存，下降沿时前一个 latch 锁存，这样就可以把数据在上升的瞬间锁存住。

#### c. Register File
Register File 包含三个地址输入和一个数据输入；包含两个数据输出。Register File 的目的是为了让通过地址读入**两个**32 比特的值（原因是因为 ALU 的计算通常是两个数字进行计算）和写入**一个**32bit 的值（存入 ALU 计算后的结果）。
Register file 通过 Decoder 将地址转成 One-hot 编码实现找到目标寄存器。通过 tri-state buffer 控制输出读取的目标寄存器。


### 2. Finity State Machine (FSM)
Finite State Machine (FSM) is a digital circuit representing a specific sequential logic system type. It is used to control and sequence the operation of digital systems, such as microprocessors, digital controllers, and other digital devices. 有限状态机时时序电路中的一种形式。它用于控制和排序数字系统的操作，如微处理器、数字控制器和其他数字设备。通常我们使用激活表格(Excitation Table) 和状态图(State Diargam)。对于无论实现什么类型的状态机，我们都需要获得两个组合逻辑电路：生成下一个状态的逻辑电路和输出逻辑电路。

通常我们有米利状态机(Mealy FSM)和摩尔状态机(Moore FSM)。这两个状态机在硬件上的**唯一区别**只有输出的组合逻辑电路。米利状态机的输出与当前状态和输入有关；摩尔状态机输出只与当前状态有关。通常情况下，米利状态机的状态会比摩尔的少，但是对于输入信号的要求更高。同时，**Mealy 的输出会比 Moore 的早一个周期，Moore 的输出永远会有一个时钟周期的延迟。**因此我们可以根据需求选择使用哪种状态机。

![Moore State Machine](/assets/img/notes/ece550/Moore.png){: width="550"}
_Moore State Machine_

![Mealy State Machine](/assets/img/notes/ece550/Mealy.png){: width="550"}
_Mealy State Machine_

**可以看到 register 输出的才是当前状态，而需要输入的则是下一个状态**。

实现状态机的步骤（无论何种状态机）为：

- 根据需求画出状态图，**并且要写出每一个状态代表的含义是什么**
- 根据状态图中的状态个数设定需要多少个 DFF 来存储状态
- 根据输入、输出画出激活表格
- 根据激活表格得到两个组合逻辑电路的逻辑表达式并用 K-Map, Q-M 法进行化简
- 根据表达式部署逻辑门，实现状态机

#### a. Moore State Machine
Moore 状态机输出只与当前状态有关。**因此，在画状态图时，输出应该画在状态中，激活表格里输出那一列没有额外的分列。**在这里使用一个例子来说明：时序输入一串二进制数字（如：100101001），使用状态机检测序列中是否有'101'存在，存在时输出 1，否则输出 0。

先画出状态图：（注意一定要检查每个状态是否有所有输入组合的指出去的箭头，总共箭头个数应该是状态总数*输入组合总数(n bit→2^n)）

![image.png](/assets/img/notes/ece550/Moore_Example.png){: width="550"}
    
根据状态图可以看到总共有四个状态，因此用 2-bit 的 DFF 即可存储状态。因此我们可以列出激活表格：
    
| Current State | Next State |            | Output |
|---------------|------------|------------|--------|
|               |     w=0    |     w=1    |        |
|       00      |     00     |     01     |    0   |
|       01      |     10     |     01     |    0   |
|       10      |     00     |     11     |    0   |
|       11      |     10     |     01     |    1   |

因此我们可以得到（这里需要一位一位看）：$$ D_{0-next}=w; D_{1-next}=D_0\overline{w}+D_1\overline{D_0}w; \\ P=D_0D_1 $$

#### b. Mealy State Machine

Mealy 除了与当前状态有关，还与输入有关。**因此，在状态图中输出应该写在输入旁边，并且激活表格中输出也有分列。**使用同样的例子来说明，先画出状态图：
![image.png](/assets/img/notes/ece550/Mealy_Example.png){: width="550"}
    
从状态个数看出，依然需要 2 个 register 来存储当前状态。因此我们可以列出激活表格为：
    
| Current State | Next State |            | Output |        |
|---------------|------------|------------|--------|--------|
|               |     w=0    |     w=1    |   w=0  |   w=1  |
|       00      |     00     |     01     |   0    |   0    |
|       01      |     10     |     01     |   0    |   0    |
|       10      |     00     |     01     |   0    |   1    |
|     **11**    |   **00**   |   **01**   | **0**  | **0**  |

> 在这里需要注意的是，其中 11 的状态我们并未使用（unused state），但是在硬件中依然存在，即便在正常工作的中的状态机不会出现这个状态。这个问题通常叫**冷启动问题**。
{: .prompt-warning }

这个问题是在于，当给状态机通电的时候，DFF 是极其不稳定的，如果刚好在不用的状态，则会不能正常进入状态机的工作状态。因此我们必须要保证让状态机在未使用状态进去到使用的状态中（最好是初始状态）。

最后我们可以写作：$$ D_{0-next}=w; D_{1-next}=\overline{D_1} D_0 \overline{w}; \\ P=D_1 \overline{D_0} $$

---

## E. Instruction Set Architecture (ISA)
Instruction set architecture is a set of instructions that the CPU could able to run. ISA 是一种能让 CPU 运行的指令集。

### 1. Code Execution

ISA is stored in 'Code' section of the process memory, with Static Data, Heap, and Stack. 程序被存储在计算机内存中 Code 的部分。对于 von Neumann 计算机结构，其执行程序的流程大致如下：

1. Instruction Fetch: Read Instruction bit from memory 获取指令
2. Decode: Figure out what those bit mean 解码或者指令含义
3. Operand Fetch: Read registers 获取运算对象
4. Execute: Do the actual operation 进行数据操作和运算
5. Result Store: Write result to register or memory 将结果存入寄存器或者内存
6. Next Instruction: Figure out mem address of next instruction 获得下一个指令

### 2. **M**icroprocessor without **I**nterlocked **P**ipeline **S**tages (MIPS)

#### a. MIPS Register file
32*32 total pointers usage in the MIPS operation system
    
![Register_usage.png](/assets/img/notes/ece550/Register_usage.png){: width="400"}
    
1. **32 × 32-bit General Purpose Integer Registers**  
   `\(0` is always 0，0 号寄存器永远是常数 0。

2. **Floating-point Registers**  
   `Lo`, `Hi`: 两个 32-bit 寄存器，常用于乘法结果或浮点数计算的中间结果存储。

3. **Special Purpose Registers**

   - **`PC` (Program Counter)**  
     `PC` 是指向当前执行指令的内存地址的指针。

     - `PC = PC + 4` → memory is byte-addressable and MIPS is 32-bit ISA。`PC` 每次加 4 是因为每条 MIPS 指令为 4 字节，内存按字节寻址。
     - `PC` 每次加 4，导致最低两位比特始终为 0，因此跳转/比较等指令通常将地址乘以 4，例如 `lw`、`sw` 指令的偏移量处理。

   - **Stack Pointer (`sp`)**  
     `sp` 指向当前栈帧的底部。

   - **Frame Pointer (`fp`)**  
     `fp` 指向当前函数栈帧顶部（便于回溯）。递归函数中，`fp` 指向该函数栈帧顶部，`sp` 继续向下增长。

   - **Return Address (`ra`)**  
     `ra` 保存函数调用返回时 `PC` 应该跳转回的位置。


#### b. MIPS Instruction format

Three main instructions: R (register-register), I (register-immediate), J (jump and call):
    
![Operation_Instructions.png](/assets/img/notes/ece550/Operation_Instructions.png){: width="550"}
    
**Opcode:** 6-bit operation code
    
**Rs**: 5-bit Source register **address** in regfile
    
**Rt**: 5-bit Target register **address** in regfile
    
**Rd**: 5-bit Destination register **address** in regfile
    
**Shamt**: 5-bit shift amount
    
**Immediate**: 16-bit immediate operand (10, 25..etc)
    
**Function**: 6-bit  function filed for identify more specific operation
    
**Address**: 26-bit target address to call / jump
    
~~**Note:** 区别R,I,J三种指令非常简单，只要有三个register出现的一定是R，只要指令中含有J的一定是J指令，其他的直接含有数字的指令都是I指令。~~

#### c. MIPS Operation

**Athematiric Operation**
    
|  Op  |     Discription      |      Example      |                 Mark                |
|------|----------------------|-------------------|-------------------------------------|
| add  | [addition]           | `add $1, $2, $3`  | 将 `$2+$3` 的值存到 `$1` 中          |
| addi | [add imm]            | `addi $1, $2, 10` | 将 `$2+10` 的值存到 `$1` 中          |
| sub  | [sub imm]            | `sub $1, $2, $3`  | 将 `$2-$3` 的值存到 `$1` 中 (没subi) |
| sll  | [shift left]         | `sll $1, $2, 10`  | 将 `$2` 左移10位并将结果存到 `$1` 中  |
| sra  | [shift right (sign)] | `sra $1, $2, 10`  | 将带符号 `$2` 右移10位并存入 `$1` 中  |

**Load & save Operation** 
    
| Op | Discription  |     Example      |                    Mark                    |
|----|--------------|------------------|--------------------------------------------|
| lw | [Load Word]  | `lw $1, 100($2)` | 从 `$2+100` 的内存地址中取出数据放到 `$1` 中 |
| sw | [Store Word] | `sw $1, 100($2)` | 将 `$1` 的数据放到 `$2+100` 的内存地址中     |
| li | [load imm]   | `li $1, 100`     | **[persudo]**将 `$1` 载入 `100 - (addi)`   |

> 例如 `lw $1, 0($2)` 形如 `$1 = *($2)`，同样的，对于 `sw $1, 0($2)`，等同于 `*($2) = $1`。`li` 指令类似于赋值指令，例如 `$1 = 100;`
{: .prompt-info }
    
**Branch & compare Instructions**
    
|  Op   |     Discription     |         Example        |                     Mark                     |
|-------|---------------------|------------------------|----------------------------------------------|
| bne   | [if not equal]      | `bne $1, $2, 10`       | 如果 `$1 ≠ $2` 则 PC 跳至 `[PC+4+10×4]`       |
| beq   | [if equal]          | `beq $1, $2, 10`       | 如果 `$1 = $2` 则 PC 跳至 `[PC+4+10×4]`       |
| bltz  | [if less than]      | `bltz $1, 10`          | 如果 `$1 < 0` 则 PC 跳至 `[PC+4+10×4]`        |
| blez  | [if less eq than]   | `blez $1, 10`          | 如果 `$1 ≤ 0` 则 PC 跳至 `[PC+4+10×4]`        |
| bgtz  | [if big than]       | `bgtz $1, 10`          | 如果 `$1 > 0` 则 PC 跳至 `[PC+4+10×4]`        |
| bgez  | [if big eq than]    | `bgez $1, 10`          | 如果 `$1 ≥ 0` 则 PC 跳至 `[PC+4+10×4]`        |
| slt   | [s less than t]     | `slt $1, $2, $3`       | 如果 `$2 < $3` 则 `$1` 为 1，否则为 0         |
| slti  | [s less than t imm] | `slti $1, $2, 100`     | 如果 `$2 < 100` 则 `$1` 为 1，否则为 0        |

**Jump Operation**
    
|  Op  |     Discription      |     Example     |               Mark                |
|------|----------------------|-----------------|-----------------------------------|
|  j   | [Jump]               | `j address`     | PC 跳转到内存为 addr 的指令        |
| jal  | [Jump & Link]        | `jal address`   | PC+4 存到 `$31` 并跳转到 addr 指令 |
| jr   | [Return]             | `jr $31`        | PC 跳转/回到 `$31` 指向的内存地址   |

> $31 在 MIPS 中是 return address register，因此会将 PC+4 存储在里面。
{: .prompt-info }

> 注意！JR 指令看似是 J 指令，实际是一个叫 JII 的指令！
{: .prompt-warning }

### 3. Function Call

Function call 的时候 ra, fp 以及所有s寄存器必须存到stack里

---

## F. Datapath

根据冯诺依曼的计算机架构，我们可以设计计算机系统为：

- Instruction Fetch: PC 指令每一次移动四个比特（对于 32 位系统），根据 PC 获得从内存中获得指令
- Decode: 解析此指令的要求，例如说明什么数据需要什么操作 
- Oprand Fetch: 根据指令从 Regfile 中获得运算数据和运算符
- Execute: 利用运算数据和运算符通过 ALU 进行运算并获得结果
- Result Store: 将结果进行存储或者从内存里取出数据
- Next Instruction: 循环整个过程

这被称之为 5-Stage 

---

## G. Pipeline

Pipeline 的作用是最大化处理器的工作流程（**improves throughtout**），使其能在每个 clock cycle 处理不同的 instructoion：



Pileline 总共有五个 stage（Fetch, Decode, Execute, Memory, Writeback）分别简称为 F, D, X, M, W, 为了使每个步骤都能单独处理不同的指令，我们需要再每一个步骤添加寄存器，存储当前的 PC，Instruction，还有当前的数据。因此每一个步骤能被单独的进行：



但是，不是所有的指令都能按照顺序一步步的放在一起。例如指令 add\)3, \(2,\)1 和 lw \(1, 0(\)3) 就不可能放在一块，原因是第二个指令 lw 需要用到 add 中 register 3 计算后的结果。如果按顺序处理就会导致处理器的结果出错。这种情况被称之为**Hazard**，而为了处理它，我们需要添加**Stall，**就是空白指令，即没有任何指令的等待。

### 1. Dependence

两个 instruction 会产生以下两种关联：

- **Data**: 两个指令需要用到同一个 register file/data location，即下一个指令需要用到上一个指令的计算结果。例如：

    ```C++
    x = y + 3;
    z = x + 3;
    ```

    Data dependences 包含四种：RAR(Read after read), RAW (Read after write), WAR (Write after read), WAW (Write after write).

- **Control**：含有 Branch，Jump 等指令必须要等到判断语句或者跳转语句获得新的 PC 之后才能知道之后需要做什么。例如：

    ```C++
    if (x > 3) { x = x + 3; }
    else {y = x - 3;}
    ```

### 2. Harzard

由于包含以上的关联性，因此会产生对应的 harzards：

- **Structual**：这个是 datapath 固有的问题，这个需要更新 ISA 以解决可能产生的问题。

- **Data**：这个 Harzard 就是刚才提到的 Data dependence 所相应会产生的问题。下一个 ins 需要用到前一个所要计算的结果，因此不能直接跟在后面。解决 Data Harzard 可以从软件和硬件方向同时解决。

    1. Software interlocks: 在不改变 pipeline 的情况下，编译器根据代码为中间插入 NOPS，称之为 code scheduling。Software interlocks 会有一定的兼容性问题。例如一个程序在 5-stage 的处理器能跑通，但是如果换到 7-stage 的处理器就不一定能正确运行，因为中间加的 nops 的数量不是正确的。

    2. Hardware interlocks: 用硬件的方式为处理器添加 NOPS。假设 regfile 是先写后读的方式，那么如果要读的寄存器和之前的 ins 需要写入的寄存器一致，那么则需要空出两个周期，为他们添加 NOPS。这个写为：

        F/D.IR.RS1 or F/D.IR.RS2 == D/X.IR.RD or X/M.IR.RD

        当出现这种情况时，**下一个指令必须要等到上一个指令 Memory stage(M) 结束后才能开始 Decode(D)。[添加两个 NOPS]**

    1. Bypass: Bypass 可以将 X stage 和 M stage 结束后的结果直接返还给 X stage 的 input 使用。这样就可以减少等待或者添加 NOPS，直接让结果用于下一个指令。

        如果有 W-X bypass，则可以在 W 的时候将值 bypass 到下一个的 X，可以减少一个 nop

        如果有 M-X bypass，则可以在 M 的时候将值 bypass 到下一个的 X，则可以再减少一个 nop，实现不需要 nop 即可完成

- **Control**：这个 Harzard 就是刚才提到的 Control dependence 所相应会产生的问题。下一个 ins 不知道将会被跳到哪一个，因此不能直接跟在后面。

    1. Branch Recovery：先假设没有 branch 取下一个地址运行，如果有 branch 了之后就把 F/D 和 D/X 的指令一下子清空成 NOPS。当出现这种 harzard 的时候，**在 branch 指令进行到 Excute stage(X)结束后下一个指令才能 Fetch(F)。[添加两个 NOPS]**

    2. Fast Branch：将 branch 和 j 的相关指令提前到 D 的步骤中，提早进行判断，这样的话只需要添加一个 NOS 即可完成

### 3. Pipeline Diagram

Pipeline Diagram 是可以描述每一个指令在同一个时间点再执行哪一个 stage。在同一个时间点不可能出现两个相同的 stage



### 4. Bypassing

W-M bypass address 是没有意义的，但是 data input 是有用的

W-M bypass 在前一个是 lw，后一个是 sw 的指令在用到 lw 出来的目标寄存器时有用

e.g. lw \(3, 0(\)2); sw \(3, 20(\)6)

但是如果 lw 后面需要对应的

X-M bypass 

e.g. addi \\(3, \\)4, 100; 

如果不 branch，则

---

## H. Memory Hierarchy

### 1. 计算机储存结构

一个计算机想要从内存中访问数据需要 MMU（memory memagement unit）来控制。每一个程序在计算机中不是单纯的共用主内存，而是通过 MMU 的帮助让每个程序”以为“他们都有 4GB 的内存。这些额外的内存实际是存储在硬盘中。这个内存地址不是物理上的内存里的数据，而是一个虚拟地址（virtual address），这时候 MMU 会使用页表（page table）将虚拟的地址映射到实际的物理地址。如果数据在主内存（main memory）中，则直接返回映射到的物理地址。处理器根据根据这个物理内存来访问 cache，并且根据 cache 是否 hit 或者 miss 更新 cache 的数据。如果数据不再主内存中，则称之为页面错误（page fault），处理器将会从硬盘中把当前 page 的内容加载到主内存中，然后再用物理地址继续去尝试是否成功 hit cache。

### 2. 存储结构（memory hierarchy）

在一个计算机系统里，处理器不会直接访问主内存（main memory），因为实主内存的速度非常的慢。然而，处理器往往会访问更小块的内存，称之为缓存（cache）。缓存比内存小很多，但是速度非常的快。但是由于缓存比较小，不一定存储了处理器想要的处理的数据。这样缓存就需要向上一级更大的缓存或者内存的数据，并把他加载进来。

![image7.png](/assets/img/notes/ece550/Memory.png){: width="100"}

因此一个缓存有以下几个参数和操作：

- **Access**： 对内存进行读写操作称之为 access

- **Hit**：在当前内存中找到了数据

- **Miss**：在当前内存没有找到数据

- **Fill**：将数据放入至内存中

- **%miss**：Miss/accesses，即没有找到数据的次数比上总访问（读写）的次数。

- **thit**：成功找到数据所需要花费的时间

- **tmiss**：没有找到数据所花费的时间

tavg = thit + %miss  *tmiss 平均访问内存的花销公式。***注意：这个里面 thit 的花销一定存在，即函数不是 tavg = thit  (1-%miss) + tmiss  %miss，因为无论什么数据都需要先查存不存在，无论是最后是不是想要的数据。**从这个公式里可以得到：Large 内存会有较低的%miss 但是 thit 比较高，相反 Small 内存会有较低的 thit 但是%miss 较高，因此我们需要使用 memory hierarchy 来调和这两个内存，让其以从小到大逐级进行缓存。

在计算机内存中有有几个比较常见的经验规则：

- **10/90 rule**：一个程序大概有 90%的时间访问大概 10%左右的内存空间

- **Temporal locality（时间上）**：一般最近被访问的数据或者指令**更加有可能之后被访问或者利用到**。

- **Spatial locality（空间上）**：一般最近被访问的数据或者指令的**附近/相邻的空间**之后更可能被访问或者利用到。

由于每一层的缓存都会更大一些, 因此在较小的缓存中使用 SRAM 结构，原因是 SRAM 速度非常快, 而后面的较大的缓存或者主要的内存就要使用 DRAM 结构，原因是 SRAM 的占用面积太大，并且非常昂贵，而 DRAM 的大小比较小, 密度较高且相对便宜。

### 3. 缓存（Cache）

**Block**： Cache 的最基础组成单元是 blocks，即每个单独的 Cache 是若干个 blocks 组成。在 32bit 系统里，每一个 block 至少是 4B。（**使用 Block 的原因是 spatial locality**）

**Set**：一个 set 可以由多个 blocks 组成。例如四个 block 可以组成一个 Set，其中每一个 block 排列称作**way**，例如一个 set 由两个 block，则就用 way0, way1 分别表示在一个 set 中的第一个 block 和第二个 block。

**注意**：如果一个 set 里只有一个 way，则说明 index 直接指向的是 block，这个称之为**direct-mapped（DM）**，如果整个 cache 只有一个 set 则说明 index 就不存在了，这个被称之为**fully-associative（FA）**。其他情况，例如一个 set 里有两个 way，则称之为**2-way set-associative（SA）**。

处理器将会使用一个 32 位的地址来寻址 Cache。整个地址分为三个部分：Tag，Index 和 Offset。

- Tag 描述的是当前 cache 是加载的 main memory 的哪一个片段

    其中 tag array 中还包含一个 1bit 的 valid bit 和一个 dirty bit，用于描述当前 blcok 是否可用和当前 block 的数值是否被更改过。（**tag array 相当于是给 cache block 额外添加的一些小标记，其大小可以用 tag overhead 衡量**）

    tag 的 bit 大小是索引的 address 大小减去 index 和 offset 的大小剩下的 bit 全部都是 tag

    tag = address / (sets * block_size)

- Index 描述额是当前的 cache 中的哪一个 block

    index 占用的 bit 个数是 block 的个数的 log2，即 8block→3bit, 4block→2bit

    index = (address / block_size) % sets

    index 是中间段的原因是在于：spetial locality 的问题。假设 index 放在最高位，那么一个连续的片段放在相同一个 block 中，如果现在将一个数组存在内存中，则再一个 block 中就会有连续的数据（...）。

- Offset 描述的是当前 block 里的哪一个 byte（因为 memory 实际上是 byte addressable，意味着每一个 byte 都可以被索引，所以用 offset 表示哪一个 byte）

    offest 的 bit 个数是一个 block 的 bytes 大小的 log2，即 4B→2bit, 8B→3bit

    offset = address % block_size

**如果认为是 HIT，在 direct-mapped 则必须要当 Set=index 的时候 tag=target_tag 且 valid bit=1，否则就是 MISS。在 X-ways associative 中，只要 Set=index 的时候，只要其中一个 way 中的 tag=target_tag 并且 valid bit=1，即认为他是 HIT 的。**

在 X-ways associative 中存在着替换的顺序问题，即如果程序发现 miss 了，程序将要将哪一个 ways 中的数据更新。这个问题有很多种解决方法：

- FIFO：用一个队列存储 block 的写入顺序，hit 后不改动 way 的顺序，还是按照顺序覆盖队头的那个 way

- LRU：用一个队列存储 block 的写入顺序，如果 hit 了就把这个 way 移到队尾。如果 Miss 了但是 ways 里还有 invalid，优先覆盖 invalid。如果 ways 里已经没有 invalid block 了，则覆盖队列头部的那个 way

- NMRU：

- Random：

- Belady's：

### 4. Write Propagation

如果需要更新 block 的数据，有两种方法进行给更新：

- Write-htru：立即更新数据，慢

- Write-back: 使用 dirty bit 用于提示是否被更改过，如果是 1 则说明更改过，在加载新的数据之前就把带有 dirty bit 的数据向下更新，然后加载新的数据进来的时候就把所有的 dirty bit 再次清零。

### 5. Performance

减少%miss 的最简单方法是增大 cache 的容量（capacity）。这虽然会导致 thit 略微增大，但是总体的 tavg 是在减小的。

如果容量固定，增大块的大小（block size）也可以更好的处理 spatial locality，减少 tag overhead，但是相应的 thit 会略微增加，同时冲突问题（conflicts）也会更加频繁

tag overhread = tag size / data size (in each block)

conflicts：不同的在主内存中的数据块映射到相同的 cache 中，致使这个 cache block 会频繁的更新，从而降低运行效率。



**Tag，index，offset 的大小变化：**

增大 block，cache 和 associativity 大小不变→tag 不变，index 减少，offset 增大

增大 sets，cache 和 associativity 大小不变→tag 不变，index 变大，offset 减少

增大 associativity，cache 和 block 的大小不变→tag 变多，index 变小，offset 不变

增大 cache，block 和 associativity 大小不变→tag 变少，index 变多，offset 不变

## Virtual Memory

使用虚拟内存的目的是给予系统的一种错觉让每个 32 位的程序都以为有 4GB 的空间可以操作。virtual memory 的好处在于，它可以让每一个系统兼容运行这个程序，不需要让程序自己去管理使用多少内存。他将部分的数据存储不在内存中的可以放在硬盘里。

Page 是硬盘中的存储单元，通常非常小（~4KB），并且受到 MMU 的管理。**使用 page 的原因是减少 PT 的大小。**

程序使用一个 virtual address（VA）的地址对一个 Page 的数据进行索引，**virtual memory 的长度就是处理器总线宽度**，32bit 系统拥有 32bit virtual memory。因为本质上 memory 和 disk 都是 Byte addressable，因此在 virtual memory 中包含两个部分，高位的部分是 virtual page number（VPN），低位的部分是 page offests（POFS），相当于告诉”一本书的第几页第几行“。

内存则使用 physical address（PA）的地址对主内存内的 Page 数据进行索引，physical address 通常比 virtual memory 小（64bit 系统），且**他的长度就是内存的大小，4GB main memory 拥有 32bit 的 physical address。**其中高位的部分为 Physical page number，低位还是 POFS。

![image8.png](/assets/img/notes/ece550/Virtual_Memory.png){: width="550"}

POFS 的大小实际上是由 page 的大小决定，例如一个 page 的大小是 64KB，则 POFS 应该是 log2(64K)=16。那么 VPN 的长度就是总线长度减去 POFS 的长度。相同的，PPN 的长度就是物理最大地址长度减去 POFS。

将虚拟地址转换为物理地址的过程为**查表（table lookup）**。这个过程通过**页表（page table）**实现，即页表里记录着这个 VPN 实际上是在物理主内存的哪个地方，还是存在硬盘中。

页表也占用空间，table 里的每一个占用的大小为**Page table entries（PTEs）**。但是如果一个页表太大，则会导致查表的速度大大减慢，因此可以使用**多级页表（muti-level page table）**，即可以将 page table 的拆分成比较小的部分。例如讲 VPN 再拆成两个部分，前一个部分用于索引第一级的 page table，后半部分查找第二级的 page table。这个就跟 virtual memory 的组成一样，相当于在说”第几个页表的第几个 page“。

**Example：**

    一个系统的总线是 X-bit，一个 page 的大小为 N Byte，主内存的大小为 M Byte，每一个 PTE 的大小为 P bytes。
    
    VA 的大小为 log2(X) bit
    
    VM 的大小为 2^X B
    
    POFS 的大小为 log2(N) bit
    
    PPN 的大小为 log2(M)-POFS bit
    
    **一级 page table：**
    
        VPN 的大小为 VA-POFS bit
    
        PT 中需要存的所有 PTE 的个数为 2^VPN 或者 VM/N （虚拟内存的大小除以 Page 大小）
    
        PT 占用的大小为 2^VPN*P B
    
    **二级 page table：**
    
        假设第一级 page table 里存的指针的大小为 Q
    
        VPNL 的大小为 log2(N/P) bit
    
        VPNH 的大小为 VA-VPNL-POFS bit
    
        VPNL 的 PT 占用大小为 N B
    
        VPNH 的 PT 占用大小为(VA-VPNL-POFS)*Q B

---

## I. Operation System

### 1. Interrupt, exception and system call

#### a. External event and interrupt

在程序运行时，通常会有**外部的事件**需要即刻被处理，例如网络数据已经完全加载，需要向硬盘读取或者写入数据，修改电脑内部时间等等。

处理器在此时可以通过两种方法进行处理：

Polling：定期持续询问是否完成 (持续询问，非常低效)

Interrupts：继续做其他任务直到外部设备提供硬件信号

- 根据外部提供的中断请求并根据中断的优先级（Interrupt controller prioritize）通知处理器

- 处理器中断当前任务的处理进程并跳转到中断处理进程（interrupt handler）中，并让 OS 进入 privileged mode。

- 处理器运行中断请求的程序

- 处理器从中断中返回之前的程序，并退出 privileged mode

在操作系统启动的时候会建立一个**interrupt vector**以设置所有的指针指向不同的中断操作的例行程序。

其中一个最常用的中断方式是计时器中断。这种方式可以使中断以定时的方式产生，从而可以让处理器同时运行多个程序（mutitasking）。【只是看起来使并行的处理多个程序，但是实际上是不断地让系统在多个程序中切换】

#### b. Exception

与 interrupt 相反，expection 是在**系统内部**指令运行的过程中一些不正常的情况从而导致处理器暂时终止运行，它通常发生在其中一个指令中，例如：虚拟地址没有被正确翻译为物理地址，除法运算除以 0，使用未定义的指令集。

与中断相比，Expections 通常会知道哪一个指令引起的错误，并且系统可能会根据不同的错误进行重试（restart）或者终止进程（kill）。

Exception 的处理方式跟中断一致，也会有一个 exception handler 让 OS 进行处理。指令集中某些指令会给出中断的数字信息。

#### c. 系统调用（System call）

当程序需要系统进行一定的操作的时候会使用 system call，例如从硬盘中获得数据，链接网络，获得准确的时间，复制新进程等。

通过使用 syscall，程序可以通过设置某些寄存器让系统知道程序的要求。但是系统有权可以拒绝程序的需求并且返回错误。这种系统调用实际上比较慢，因此，为了避免多次使用系统调用，使用用户空间（Userspace libraries）会更加迅速，例如 malloc 函数会分配内存，但是实际上他不会每次做 system call，而是系统调用一次很大的内存块给程序，然后程序自己分配和管理那个内存块。

### 2. 文件系统（Filesystem）

在硬盘和系统中，每一个可以被索引到的存储单元可以称作为 Blocks。Blocks 可以被整合为 block groups。一个系统中的 Filesystem 就是由若干个 blocks 组成的。

在 UNIX 系统下，**Inode**是用于描述其 Filesystems 的数据结构。它包含了所有的关于这个文件的信息，包括所有者，权限，访问时间，被存储在哪个地方，占用了多少空间，**唯独不保存文件名**。Inodes 的大小是固定的**256 bytes**。

在 inode 中，文件保存的数据用**指针**描述。它保存的是每个 block 的地址。由于每一个 block 的大小比较小（例如 4KB），使用所有的指针指向直接的数据 blcok 的大小也比较小（**Functionality problem**），因此我们需要**Add a level of indirection，**即 inode 指针指向的 block 中也全部是指针，分别再指向数据，这样子指向的数据就比较多了，但是坏处是添加 indirection 会使访问数据的速度变慢，对于小文件非常不值得，因此再实际的 indoes 中包含：

- 12 direct pointer（直接指向数据 block，可以包含 48KB 数据）

- 1 indirect pointer（一层 indirection，可以额外包含 4MB 数据）

- 1 doubly indirect pointer（二层 indirection，可以额外包含 4GB 数据）

- 1 triply indirect pointer（三层 indirection，可以而外包含 4TB 数据）

通过包含不同层级的指针和 indirection，小文件可以通过 direct pointers，比较大的文件可以分别通过使用一级至三级的 indirection 指针进行保存，从而达到大文件小文件都可以用 inode 保存，并且能保证小文件存取速度快。大文件也可以通过使用 cache 保存 indirect blocks 中的 pointers 让访问的速度变快。这是一种**make the common case fast 的一种表现。**

Example：



在 UNIX 系统中，**路径（directories）也是一个文件，用 inode 存储。**这样每个 directories 的 inode 的里存储的是{name, inode #}的键值对，他们也是指针，相当于指向的是路径下的文件的 inode！因此，如果要找到某一个路径底下的文件，会在这个键值对中寻找（遍历）匹配的 name，然后获得其 inode 的指针，找到的对应的文件。

除了路径，UNIX 系统的文件类型还包括：（也都是用 inodes）

- Regular file：常规的所有文件

- Directories：路径

- FIFO（First-in first-out）：通过队列的方式使得两个 process 进行通讯

- Symlinks

- Device：硬件设备

- Sockets

### 3. 进程（Processes）

一个进程是一个正在运行的程序的实例（**Instance of a program**）。每一个 process 都有一个 Process ID（**PID**），并且都是不同的，用于区分每一个 process。在一个 OS 系统里都会存在一个 scheduler 用于计划指令的顺序。最基础的就是一个简单的循环队列，更高级的包含优先计划和更高级的算法，而 OS 自身会知道什么 process 正在运行。

#### a. 上下文切换（Context Switch）

当遇到中断（Interrupt）时，scheduler 会找到接下来需要运行什么。这时候 OS 会执行上下文切换（**context switch**）

- 当前的所有寄存器内的值都会 OS 的预处理数据结构中

- 将当前处理器的根页表指向新的 process 的页表（页表：虚拟内存实现中用于存储物理地址和虚拟地址之间映射关系的数据结构）

- 将新进程的数据加载进寄存器中并运行新进程

- 当中断任务完成后，系统将会从中断进程中返回，获得原先保存的数据和 PC，继续执行之前的任务

#### b. 创建进程（Process Creation）

生成一个新的 Process 可以通过很多种方法，其中最常见的一种是通过**复制当前的进程**。使用复制来生成新的进程有诸多好处：他能复制当前的环境变量，原始设置等，减少重复操作；其次是在 memory 中不需要额外花时间加载新的东西，所有的数据、代码片段等都已经存在（注意：**只会拷贝页表**，也就是说只拷贝指针（浅拷贝），这样可以不用复制所有的数据，两者指向同一个地方）。因此使用这种方法开始新的进程的效率会比较高。

在 UNIX 系统中，可以使用**fork()**函数来复制当前进程。如果此函数返回 0，说明这是子进程（复制出来的进程），如果>0，则返回的值是子进程的 PID，并且说明是父进程。但是复制之后**不能保证哪一个先被运行**，即使是父进程也不一定会先运行，多核处理器可以同时运行子和父进程。

当复制完新进程后，可以使用**exec()**函数将新的程序加载进入内存，并且将会覆盖当前存在内存中的数据和重置栈和堆的指针，成功执行 exec 后，执行 exec 调用的原始程序将不再存在于进程中，而新加载的程序将接管执行。**因此，除非在执行 exec 操作期间发生错误，否则原始程序不会在调用 exec 之后恢复执行（never return）。**

kill() 函数可以把当前的进程杀死。但是其不是立刻回到父进程的操作，实际上是向当前进程发送一个信号。当前进程可以根据这个信号做出反应，也可以完全忽略此信号。

#### c. 线程（threads）

一个进程中包含很多线程（threads）。线程可以同时进行（**excute concurrently**），有着独立的寄存器和独立的栈空间（**different register and stack**），但是他们共享同一个虚拟地址（**share virtual address space**）。由于线程可以同步进行，程序需要有同步性（synchronization）来保证不同进程之间能正确的共享数据，没有竞争和冲突的关系。

#### d. 启动（Booting）

我们需要**Bootloader**来获取我们电脑的第一个进程。在电脑启动时，vierual memory 不可用，BIOS 通过启动代码（startup code）启动并开始读取硬盘 0 号分区的内容（通常非常小的分区）来启动（First stage bootloader）。然后他会根据这个内容读取第二阶段的分区内容（second stage bootloader），包含一些简单的菜单和选项，并且读取文件系统并将 OS 核心加载到内存中并启动。当 OS 核心启动后，页表，中断处理，空闲进程等就会建立。

**Init 是计算机中第一个正常的程序，OS 将加载/bin/init，并将此进程的 PID 设为 1。**Init 将会阅读在/etc 中所有的配置信息，通过/bin/login, ssdh 等路径生成（spawn）其他的进程和程序，并且定期清理一些孤立或者终止的进程。

### 4. 接口（input output I/O）

一个电脑系统包含了很多 IO 接口，因为这是与外界进行交互的窗口。处理器接收和处理这些 IO 设备的信号通常有两种方法：

- 设置 In/Out 指令集（**In/Out instruction**）：可以使处理器从固定的 IO 接口读和写入

- 内存映射（**Memory mapped**）：将一部分的物理地址直接映射到 IO 设备中，IO 设备的数据的读或者写的数据都被地址映射了，处理器可以直接通过访问内存的方式访问这些接口。

#### a. Load data from disk to memory

之前已经提到过 OS 会使用中断来加载硬盘中的数据。那么将硬盘中的数据加载到内存中有两种方式：

- 使用 OS 中的指令，将内存映射为硬盘的接口的数据写入到主内存中。每次写入几 KB 至几 MB 不等，直至写入完成。

- 使用 DMA（**Direct Memory Access**）：设置 DMA，让 DMA 去做加载硬盘数据到内存数据的操作，完成后反馈给 CPU（间接方式实现加载）

#### b. Reliability

增大一个系统的稳定性有不同的操作：

- 解决文件存储大小的问题（**Functionality problem**）：添加 indirection（Filesystem）

- 解决处理性能的问题（**Performance problem**）：添加 cache（Memory Hierachy）

- 解决数据可靠性的问题（**Reliability problem**）：添加 redundancy（冗余数据→使用 RAID 系统）

RAID 系统（Redundant Array of Inexpensive Disks）是一种简单且暴力的方法，即将相同的数据保存很多份以增加数据的可靠性；如果复制一份，则叫 RAID1。如果其中一个盘的数据损坏或者不正确，只需要将另外一个的数据拿来覆盖即可。



Interrupt are not linked to instructions running on the CPU

Pipeline improves throughout

performance problem→cache



[MIPS Opcode](/assets/files/MIPS_Opcode_Reference.xlsx)

